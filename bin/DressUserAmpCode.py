#! /usr/bin/env python3

import argparse 
import re 

def main(): 

    # Parse arguments 
    parser = argparse.ArgumentParser(description = 'Dress Fortran code generated by the user (e.g. with FeynCalc) in order to work with H1jet.', epilog = "Remember to specify the generated file in USERPATH when building H1jet.")

    parser.add_argument('inputfile', nargs = '+', type = str, action = 'append', help = 'Input Fortran code file(s) for dressing') 

    parser.add_argument('-o', '--out', dest = 'outfile', nargs = '?', action = 'store', default = 'user_interface.f90', help = 'Output Fortran code file (default: "user_interface.f90")') 

    args = parser.parse_args()

    # Container for amplitude code lines 
    amplitudelines = [] 

    # Container for born cross section lines 
    xseclines = [] 

    # Container for channels used 
    channels = [] 

    # Variables for additional parameters 
    par_nf = False
    par_me = False
    par_mmu = False
    par_mtau = False
    par_mu = False
    par_md = False
    par_mc = False
    par_ms = False
    par_mq = False
    par_mQ = False
    par_mqu = False
    par_mqd = False
    par_ml = False
    par_mpi = False
    par_e_Q = False
    par_Q_u = False
    par_Q_d = False
    par_cosC = False
    par_sinC = False
    par_thetaC = False
    par_Vud = False
    par_cVud = False
    par_Vus = False
    par_cVus = False
    par_Vub = False
    par_cVub = False
    par_Vcd = False
    par_cVcd = False
    par_Vcs = False
    par_cVcs = False
    par_Vcb = False
    par_cVcb = False
    par_Vtd = False
    par_cVtd = False
    par_Vts = False
    par_cVts = False
    par_Vtb = False
    par_cVtb = False
    par_s12 = False
    par_s13 = False
    par_s23 = False
    par_c12 = False
    par_c13 = False
    par_c23 = False

    # Container for found unknown parameters 
    foundparameters = [] 

    higgsMassUsed = False 

    # Container for the level of implementation 
    user_included = "id_missingTotXsec" 

    # Loop over all input files 
    for filelist in args.inputfile: 

        for filename in filelist: 

            print("Reading input from file: " + filename)

            # Open file 
            with open(filename) as inputfile: 

                # Read lines 
                # The generated file is not very large so we can read the entire file at once 
                lines = [line.rstrip('\n') for line in inputfile]

                xsecline = False

                # Loop over lines 
                for i in range(len(lines)):

                    # Remove whitespace to the left 
                    modifiedline = lines[i].lstrip()

                    # Add ampersand if multiple lines 
                    if ((i + 1) < (len(lines))): 
                        # Check if next line is empty 
                        if lines[i+1].strip(): 
                            if ((lines[i+1].lstrip())[0] == '&'): 
                                modifiedline = modifiedline + ' & '

                    # Add appropriate whitespace 
                    if (len(modifiedline) > 0): 
                        if (modifiedline[0] == 'w'): 
                            modifiedline = '    ' + modifiedline 
                        elif (modifiedline[0] == '&'): 
                            modifiedline = '           ' + modifiedline 

                    # Parse line 

                    # If line starts with "channel = "
                    if (re.search('=', modifiedline)): 

                        # Get the channel 
                        channel = modifiedline[:modifiedline.find("=")].strip() 

                        # Substitute contributions 
                        # Check if matrix element or total cross section 
                        if (channel.startswith('xs')): 
                            # Total cross section
                            xsecline = True
                        else: 
                            # Matrix element 
                            # Save the channel 
                            channels.append(channel)
                            # Modify channel 
                            channel = 'wt' + channel

                        # Remove the 'bar' from the name 
                        channel = channel.replace('bar', '')

                        # Change all quarks to 'q' 
                        channel = channel.replace('u', 'q')
                        channel = channel.replace('d', 'q')
                        channel = channel.replace('c', 'q')
                        channel = channel.replace('s', 'q')
                        channel = channel.replace('b', 'q')
                        
                        # Modify the line 
                        newChannel = '    ' + channel + ' = ' + channel + ' + ' 
                        modifiedline = re.sub('^.* = ', newChannel, modifiedline)

                        # Check for any unrecognised channel 
                        if (channel != 'wtgg' and channel != 'wtgq' and channel != 'wtqg' and channel != 'wtqq' and channel != 'xsgg' and channel != 'xsgq' and channel != 'xsqg' and channel != 'xsqq'): 
                            print("WARNING: Unrecognised channel found: " + channel) 
                            print("Please only use combinations of g, u, d, c, s, b, q, ubar, dbar, cbar, sbar, bbar, qbar.")
                            print("Examples: gg, gb, bbbar, ubard, ubarubar, ...") 

                    # Check if Higgs mass is there 
                    if (re.search('SMP\("m_H"\)', modifiedline)): 
                        higgsMassUsed = True 

                    # Substitute H1jet parameters 
                    modifiedline = re.sub('SMP\("m_H"\)', 'c_mH', modifiedline) 
                    modifiedline = re.sub('SMP\("m_Z"\)', 'mz_in', modifiedline) 
                    modifiedline = re.sub('SMP\("m_W"\)', 'mw_in', modifiedline) 
                    modifiedline = re.sub('SMP\("m_t"\)', 'mt_in', modifiedline) 
                    modifiedline = re.sub('SMP\("m_b"\)', 'mb_in', modifiedline) 
                    modifiedline = re.sub('SMP\("G_F"\)', 'GF_GeVm2_in', modifiedline) 
                    modifiedline = re.sub('SMP\("sin_W"\)', 'sqrt(sinwsq_in)', modifiedline) # Sign is lost 
                    modifiedline = re.sub('SMP\("cos_W"\)', 'sqrt(one-sinwsq_in)', modifiedline) # Sign is lost 
                    modifiedline = re.sub('SMP\("theta_W"\)', 'asin(sqrt(sinwsq_in))', modifiedline) # Sign is lost 
                    modifiedline = re.sub('SMP\("g_W"\)', '(two*mw_in/higgs_vev_in)', modifiedline) 
                    modifiedline = re.sub('SMP\("g\'_W"\)', '((two*mw_in/higgs_vev_in)*sqrt(sinwsq_in)/sqrt(one-sinwsq_in))', modifiedline) 
                    modifiedline = re.sub('SMP\("g_s"\)', 'sqrt(four*pi*alphas)', modifiedline) 
                    modifiedline = re.sub('SMP\("alpha_s"\)', 'alphas', modifiedline) 
                    modifiedline = re.sub('SMP\("e"\)', '(two*sqrt(sinwsq_in)*mw_in*sqrt(sqrt(two)*GF_GeVm2_in))', modifiedline) 
                    modifiedline = re.sub('SMP\("alpha_fs"\)', '(sqrt(two)*sinwsq_in*mw_in**two*GF_GeVm2_in/pi)', modifiedline) 
                    modifiedline = re.sub('SMP\("g"\)', '(two*sqrt(sinwsq_in)*mw_in*sqrt(sqrt(two)*GF_GeVm2_in))', modifiedline) 

                    # Check for additional SMP parameters 
                    if (re.search('SMP\("N_F"\)', modifiedline)): 
                        par_nf = True
                        modifiedline = re.sub('SMP\("N_F"\)', 'c_nf', modifiedline) 
                    if (re.search('SMP\("m_e"\)', modifiedline)): 
                        par_me = True
                        modifiedline = re.sub('SMP\("m_e"\)', 'c_me', modifiedline) 
                    if (re.search('SMP\("m_mu"\)', modifiedline)): 
                        par_mmu = True
                        modifiedline = re.sub('SMP\("m_mu"\)', 'c_mmu', modifiedline) 
                    if (re.search('SMP\("m_tau"\)', modifiedline)): 
                        par_mtau = True
                        modifiedline = re.sub('SMP\("m_tau"\)', 'c_mtau', modifiedline) 
                    if (re.search('SMP\("m_u"\)', modifiedline)): 
                        par_mu = True
                        modifiedline = re.sub('SMP\("m_u"\)', 'c_mu', modifiedline) 
                    if (re.search('SMP\("m_d"\)', modifiedline)): 
                        par_md = True
                        modifiedline = re.sub('SMP\("m_d"\)', 'c_md', modifiedline) 
                    if (re.search('SMP\("m_c"\)', modifiedline)): 
                        par_mc = True
                        modifiedline = re.sub('SMP\("m_c"\)', 'c_mc', modifiedline) 
                    if (re.search('SMP\("m_s"\)', modifiedline)): 
                        par_ms = True
                        modifiedline = re.sub('SMP\("m_s"\)', 'c_ms', modifiedline) 
                    if (re.search('SMP\("m_q"\)', modifiedline)): 
                        par_mq = True
                        modifiedline = re.sub('SMP\("m_q"\)', 'c_mq', modifiedline) 
                    if (re.search('SMP\("m_Q"\)', modifiedline)): 
                        par_mQ = True
                        modifiedline = re.sub('SMP\("m_Q"\)', 'c_mQ', modifiedline) 
                    if (re.search('SMP\("m_qu"\)', modifiedline)): 
                        par_mqu = True
                        modifiedline = re.sub('SMP\("m_qu"\)', 'c_mqu', modifiedline) 
                    if (re.search('SMP\("m_qd"\)', modifiedline)): 
                        par_mqd = True
                        modifiedline = re.sub('SMP\("m_qd"\)', 'c_mqd', modifiedline) 
                    if (re.search('SMP\("m_l"\)', modifiedline)): 
                        par_ml = True
                        modifiedline = re.sub('SMP\("m_l"\)', 'c_ml', modifiedline) 
                    if (re.search('SMP\("m_pi"\)', modifiedline)): 
                        par_mpi = True
                        modifiedline = re.sub('SMP\("m_pi"\)', 'c_mpi', modifiedline) 
                    if (re.search('SMP\("e_Q"\)', modifiedline)): 
                        par_e_Q = True
                        modifiedline = re.sub('SMP\("e_Q"\)', 'c_e_Q', modifiedline) 
                    if (re.search('SMP\("Q_u"\)', modifiedline)): 
                        par_Q_u = True
                        modifiedline = re.sub('SMP\("Q_u"\)', 'c_Q_u', modifiedline) 
                    if (re.search('SMP\("Q_d"\)', modifiedline)): 
                        par_Q_d = True
                        modifiedline = re.sub('SMP\("Q_d"\)', 'c_Q_d', modifiedline) 
                    if (re.search('SMP\("cos_C"\)', modifiedline)): 
                        par_cosC = True
                        modifiedline = re.sub('SMP\("cos_C"\)', 'c_cosC', modifiedline) 
                    if (re.search('SMP\("sin_C"\)', modifiedline)): 
                        par_sinC = True
                        modifiedline = re.sub('SMP\("sin_C"\)', 'c_sinC', modifiedline) 
                    if (re.search('SMP\("theta_C"\)', modifiedline)): 
                        par_thetaC = True
                        modifiedline = re.sub('SMP\("theta_C"\)', 'c_thetaC', modifiedline) 
                    if (re.search('SMP\("V_ud",\(0.,1.\)\)', modifiedline)): 
                        par_Vud = True
                        modifiedline = re.sub('SMP\(""\)', 'c_Vud', modifiedline) 
                    if (re.search('SMP\("V_ud",\(0.,-1.\)\)', modifiedline)): 
                        par_cVud = True
                        modifiedline = re.sub('SMP\(""\)', 'c_cVud', modifiedline) 
                    if (re.search('SMP\("V_us",\(0.,1.\)\)', modifiedline)): 
                        par_Vus = True
                        modifiedline = re.sub('SMP\(""\)', 'c_Vus', modifiedline) 
                    if (re.search('SMP\("V_us",\(0.,-1.\)\)', modifiedline)): 
                        par_cVus = True
                        modifiedline = re.sub('SMP\(""\)', 'c_cVus', modifiedline) 
                    if (re.search('SMP\("V_ub",\(0.,1.\)\)', modifiedline)): 
                        par_Vub = True
                        modifiedline = re.sub('SMP\(""\)', 'c_Vub', modifiedline) 
                    if (re.search('SMP\("V_ub",\(0.,-1.\)\)', modifiedline)): 
                        par_cVub = True
                        modifiedline = re.sub('SMP\(""\)', 'c_cVub', modifiedline) 
                    if (re.search('SMP\("V_cd",\(0.,1.\)\)', modifiedline)): 
                        par_Vcd = True
                        modifiedline = re.sub('SMP\(""\)', 'c_Vcd', modifiedline) 
                    if (re.search('SMP\("V_cd",\(0.,-1.\)\)', modifiedline)): 
                        par_cVcd = True
                        modifiedline = re.sub('SMP\(""\)', 'c_cVcd', modifiedline) 
                    if (re.search('SMP\("V_cs",\(0.,1.\)\)', modifiedline)): 
                        par_Vcs = True
                        modifiedline = re.sub('SMP\(""\)', 'c_Vcs', modifiedline) 
                    if (re.search('SMP\("V_cs",\(0.,-1.\)\)', modifiedline)): 
                        par_cVcs = True
                        modifiedline = re.sub('SMP\(""\)', 'c_cVcs', modifiedline) 
                    if (re.search('SMP\("V_cb",\(0.,1.\)\)', modifiedline)): 
                        par_Vcb = True
                        modifiedline = re.sub('SMP\(""\)', 'c_Vcb', modifiedline) 
                    if (re.search('SMP\("V_cb",\(0.,-1.\)\)', modifiedline)): 
                        par_cVcb = True
                        modifiedline = re.sub('SMP\(""\)', 'c_cVcb', modifiedline) 
                    if (re.search('SMP\("V_td",\(0.,1.\)\)', modifiedline)): 
                        par_Vtd = True
                        modifiedline = re.sub('SMP\(""\)', 'c_Vtd', modifiedline) 
                    if (re.search('SMP\("V_td",\(0.,-1.\)\)', modifiedline)): 
                        par_cVtd = True
                        modifiedline = re.sub('SMP\(""\)', 'c_cVtd', modifiedline) 
                    if (re.search('SMP\("V_ts",\(0.,1.\)\)', modifiedline)): 
                        par_Vts = True
                        modifiedline = re.sub('SMP\(""\)', 'c_Vts', modifiedline) 
                    if (re.search('SMP\("V_ts",\(0.,-1.\)\)', modifiedline)): 
                        par_cVts = True
                        modifiedline = re.sub('SMP\(""\)', 'c_cVts', modifiedline) 
                    if (re.search('SMP\("V_tb",\(0.,1.\)\)', modifiedline)): 
                        par_Vtb = True
                        modifiedline = re.sub('SMP\(""\)', 'c_Vtb', modifiedline) 
                    if (re.search('SMP\("V_tb",\(0.,-1.\)\)', modifiedline)): 
                        par_cVtb = True
                        modifiedline = re.sub('SMP\(""\)', 'c_cVtb', modifiedline) 
                    if (re.search('SMP\("s_12"\)', modifiedline)): 
                        par_s12 = True
                        modifiedline = re.sub('SMP\("s_12"\)', 'c_s12', modifiedline) 
                    if (re.search('SMP\("s_13"\)', modifiedline)): 
                        par_s13 = True
                        modifiedline = re.sub('SMP\("s_13"\)', 'c_s13', modifiedline) 
                    if (re.search('SMP\("s_23"\)', modifiedline)): 
                        par_s23 = True
                        modifiedline = re.sub('SMP\("s_23"\)', 'c_s23', modifiedline) 
                    if (re.search('SMP\("c_12"\)', modifiedline)): 
                        par_c12 = True
                        modifiedline = re.sub('SMP\("c_12"\)', 'c_c12', modifiedline) 
                    if (re.search('SMP\("c_13"\)', modifiedline)): 
                        par_c13 = True
                        modifiedline = re.sub('SMP\("c_13"\)', 'c_c13', modifiedline) 
                    if (re.search('SMP\("c_23"\)', modifiedline)): 
                        par_c23 = True
                        modifiedline = re.sub('SMP\("c_23"\)', 'c_c23', modifiedline) 

                    # Find all unknown parameters, i.e. not SMP parameters 
                    currentline = lines[i]
                    # Remove "=" and everything left of it 
                    currentline = currentline[currentline.find('=')+1:] 
                    # Remove all "SMP(...)" 
                    currentline = re.sub(r'SMP\("(.*?)"\)', '', currentline) 
                    # Find all "words" 
                    currentlinewords = re.findall(r'\w+', currentline) 
                    # Loop over all found "words"
                    for word in currentlinewords: 
                        # Ignore all "s", "t", and "u" 
                        if (word != 's' and word != 't' and word != 'u'): 
                            # If not a digit 
                            if (word.isdigit() == False): 
                                # If parameter has not already been saved 
                                if ('c_' + word not in foundparameters): 
                                    # Save the found parameter 
                                    foundparameters.append('c_' + word) 
                    # Modify the line with all the new parameters 
                    for foundpar in foundparameters: 
                        modifiedline = re.sub(foundpar[2:], foundpar, modifiedline) 

                    # Check if the line is over 80 chars 
                    #if (len(modifiedline) > 80): 
                    #    modifiedline = modifiedline[:70] + ' & \n' + '           & ' + modifiedline[70:] 

                    # Add the modified line to the final output 
                    if (len(modifiedline) > 0): 
                        if (xsecline == True): 
                            xseclines.append(modifiedline)
                        else: 
                            amplitudelines.append(modifiedline)

                if (xsecline == True): 
                    user_included = "id_fullImplementation" 

    # Containers for additional parameters 
    par_declarations = [] 
    par_definitions = [] 
    par_message = [] 

    # Add the Higgs mass if used 
    if (higgsMassUsed == True): 
        par_declarations.append("    real(dp) :: c_mH")
        par_definitions.append("    c_mH = dble_val_opt('--mH', mh) ! Higgs mass")

    # Additional SMP parameters 
    if (par_nf): 
        par_declarations.append("    integer :: c_nf")
        par_definitions.append("    c_nf = int_val_opt('--c_nf', 5)")
        par_message.append("  --c_nf <value>        Number of flavours (user), default = 5")
    if (par_me): 
        par_declarations.append("    real(dp) :: c_me")
        par_definitions.append("    c_me = dble_val_opt('--c_me', 5.11e-4_dp)")
        par_message.append("  --c_me <value>        Electron mass [GeV] (user), default = 5.11e-4")
    if (par_mmu): 
        par_declarations.append("    real(dp) :: c_mmu")
        par_definitions.append("    c_mmu = dble_val_opt('--c_mmu', 0.106_dp)")
        par_message.append("  --c_mmu <value>       Muon mass [GeV] (user), default = 0.106")
    if (par_mtau): 
        par_declarations.append("    real(dp) :: c_mtau")
        par_definitions.append("    c_mtau = dble_val_opt('--c_mtau', 1.776_dp)")
        par_message.append("  --c_mtau <value>      Tau mass [GeV] (user), default = 1.776")
    if (par_mu): 
        par_declarations.append("    real(dp) :: c_mu")
        par_definitions.append("    c_mu = dble_val_opt('--c_mu', 0.0_dp)")
        par_message.append("  --c_mu <value>        Up quark mass [GeV] (user), default = 0")
    if (par_md): 
        par_declarations.append("    real(dp) :: c_md")
        par_definitions.append("    c_md = dble_val_opt('--c_md', 0.0_dp)")
        par_message.append("  --c_md <value>        Down quark mass [GeV] (user), default = 0")
    if (par_mc): 
        par_declarations.append("    real(dp) :: c_mc")
        par_definitions.append("    c_mc = dble_val_opt('--c_mc', 1.275_dp)")
        par_message.append("  --c_mc <value>        Charm quark mass [GeV] (user), default = 1.275")
    if (par_ms): 
        par_declarations.append("    real(dp) :: c_ms")
        par_definitions.append("    c_ms = dble_val_opt('--c_ms', 0.0_dp)")
        par_message.append("  --c_ms <value>        Strange quark mass [GeV] (user), default = 0")
    if (par_mq): 
        par_declarations.append("    real(dp) :: c_mq")
        par_definitions.append("    c_mq = dble_val_opt('--c_mq', 0.0_dp)")
        par_message.append("  --c_mq <value>        Quark mass [GeV] (user), default = 0")
    if (par_mQ): 
        par_declarations.append("    real(dp) :: c_mQ")
        par_definitions.append("    c_mQ = dble_val_opt('--c_mQ', 0.0_dp)")
        par_message.append("  --c_mQ <value>        Quark mass [GeV] (user), default = 0")
    if (par_mqu): 
        par_declarations.append("    real(dp) :: c_mqu")
        par_definitions.append("    c_mqu = dble_val_opt('--c_mqu', 0.0_dp)")
        par_message.append("  --c_mqu <value>       Up-type quark mass [GeV] (user), default = 0")
    if (par_mqd): 
        par_declarations.append("    real(dp) :: c_mqd")
        par_definitions.append("    c_mqd = dble_val_opt('--c_mqd', 0.0_dp)")
        par_message.append("  --c_mqd <value>       Down-type quark mass [GeV] (user), default = 0")
    if (par_ml): 
        par_declarations.append("    real(dp) :: c_ml")
        par_definitions.append("    c_ml = dble_val_opt('--c_ml', 0.0_dp)")
        par_message.append("  --c_ml <value>        Lepton mass [GeV] (user), default = 0")
    if (par_mpi): 
        par_declarations.append("    real(dp) :: c_mpi")
        par_definitions.append("    c_mpi = dble_val_opt('--c_mpi', 135.0_dp)")
        par_message.append("  --c_mpi <value>       Pion mass [GeV] (user), default = 135.0")
    if (par_e_Q): 
        par_declarations.append("    real(dp) :: c_e_Q")
        par_definitions.append("    c_e_Q = dble_val_opt('--c_e_Q', 0.66666667_dp)")
        par_message.append("  --c_e_Q <value>       Electric charge of quark (user), default = 2/3")
    if (par_Q_u): 
        par_declarations.append("    real(dp) :: c_Q_u")
        par_definitions.append("    c_Q_u = dble_val_opt('--c_Q_u', 0.66666667_dp)")
        par_message.append("  --c_Q_u <value>       Up-quark charge (user), default = 2/3")
    if (par_Q_d): 
        par_declarations.append("    real(dp) :: c_Q_d")
        par_definitions.append("    c_Q_d = dble_val_opt('--c_Q_d', -0.33333333_dp)")
        par_message.append("  --c_Q_d <value>       Down-quark charge (user), default = -1/3")
    if (par_cosC): 
        par_declarations.append("    real(dp) :: c_cosC")
        par_definitions.append("    c_cosC = dble_val_opt('--c_cosC', 0.98_dp)")
        par_message.append("  --c_cosC <value>      Cosine of Cabibbo angle (user), default = 0.98")
    if (par_sinC): 
        par_declarations.append("    real(dp) :: c_sinC")
        par_definitions.append("    c_sinC = dble_val_opt('--c_sinC', 0.22_dp)")
        par_message.append("  --c_sinC <value>      Sine of Cabibbo angle (user), default = 0.22")
    if (par_thetaC): 
        par_declarations.append("    real(dp) :: c_thetaC")
        par_definitions.append("    c_thetaC = dble_val_opt('--c_thetaC', 0.22_dp)")
        par_message.append("  --c_thetaC <value>    Cabibbo angle (user), default = 0.22")
    if (par_Vud): 
        par_declarations.append("    real(dp) :: c_Vud")
        par_definitions.append("    c_Vud = dble_val_opt('--c_Vud', 1.0_dp)")
        par_message.append("  --c_Vud <value>       CKM ud real part (user), default = 1")
    if (par_cVud): 
        par_declarations.append("    real(dp) :: c_cVud")
        par_definitions.append("    c_cVud = dble_val_opt('--c_cVud', 0.0_dp)")
        par_message.append("  --c_cVud <value>      CKM ud imaginary part (user), default = 0")
    if (par_Vus): 
        par_declarations.append("    real(dp) :: c_Vus")
        par_definitions.append("    c_Vus = dble_val_opt('--c_Vus', 0.0_dp)")
        par_message.append("  --c_Vus <value>       CKM us real part (user), default = 0")
    if (par_cVus): 
        par_declarations.append("    real(dp) :: c_cVus")
        par_definitions.append("    c_cVus = dble_val_opt('--c_cVus', 0.0_dp)")
        par_message.append("  --c_cVus <value>      CKM us imaginary part (user), default = 0")
    if (par_Vub): 
        par_declarations.append("    real(dp) :: c_Vub")
        par_definitions.append("    c_Vub = dble_val_opt('--c_Vub', 0.0_dp)")
        par_message.append("  --c_Vub <value>       CKM ub real part (user), default = 0")
    if (par_cVub): 
        par_declarations.append("    real(dp) :: c_cVub")
        par_definitions.append("    c_cVub = dble_val_opt('--c_cVub', 0.0_dp)")
        par_message.append("  --c_cVub <value>      CKM ub imaginary part (user), default = 0")
    if (par_Vcd): 
        par_declarations.append("    real(dp) :: c_Vcd")
        par_definitions.append("    c_Vcd = dble_val_opt('--c_Vcd', 0.0_dp)")
        par_message.append("  --c_Vcd <value>       CKM cd real part (user), default = 0")
    if (par_cVcd): 
        par_declarations.append("    real(dp) :: c_cVcd")
        par_definitions.append("    c_cVcd = dble_val_opt('--c_cVcd', 0.0_dp)")
        par_message.append("  --c_cVcd <value>      CKM cd imaginary part (user), default = 0")
    if (par_Vcs): 
        par_declarations.append("    real(dp) :: c_Vcs")
        par_definitions.append("    c_Vcs = dble_val_opt('--c_Vcs', 1.0_dp)")
        par_message.append("  --c_Vcs <value>       CKM cs real part (user), default = 1")
    if (par_cVcs): 
        par_declarations.append("    real(dp) :: c_cVcs")
        par_definitions.append("    c_cVcs = dble_val_opt('--c_cVcs', 0.0_dp)")
        par_message.append("  --c_cVcs <value>      CKM cs imaginary part (user), default = 0")
    if (par_Vcb): 
        par_declarations.append("    real(dp) :: c_Vcb")
        par_definitions.append("    c_Vcb = dble_val_opt('--c_Vcb', 0.0_dp)")
        par_message.append("  --c_Vcb <value>       CKM cb real part (user), default = 0")
    if (par_cVcb): 
        par_declarations.append("    real(dp) :: c_cVcb")
        par_definitions.append("    c_cVcb = dble_val_opt('--c_cVcb', 0.0_dp)")
        par_message.append("  --c_cVcb <value>      CKM cb imaginary part (user), default = 0")
    if (par_Vtd): 
        par_declarations.append("    real(dp) :: c_Vtd")
        par_definitions.append("    c_Vtd = dble_val_opt('--c_Vtd', 0.0_dp)")
        par_message.append("  --c_Vtd <value>       CKM td real part (user), default = 0")
    if (par_cVtd): 
        par_declarations.append("    real(dp) :: c_cVtd")
        par_definitions.append("    c_cVtd = dble_val_opt('--c_cVtd', 0.0_dp)")
        par_message.append("  --c_cVtd <value>      CKM td imaginary part (user), default = 0")
    if (par_Vts): 
        par_declarations.append("    real(dp) :: c_Vts")
        par_definitions.append("    c_Vts = dble_val_opt('--c_Vts', 0.0_dp)")
        par_message.append("  --c_Vts <value>       CKM ts real part (user), default = 0")
    if (par_cVts): 
        par_declarations.append("    real(dp) :: c_cVts")
        par_definitions.append("    c_cVts = dble_val_opt('--c_cVts', 0.0_dp)")
        par_message.append("  --c_cVts <value>      CKM ts imaginary part (user), default = 0")
    if (par_Vtb): 
        par_declarations.append("    real(dp) :: c_Vtb")
        par_definitions.append("    c_Vtb = dble_val_opt('--c_Vtb', 1.0_dp)")
        par_message.append("  --c_Vtb <value>       CKM tb real part (user), default = 1")
    if (par_cVtb): 
        par_declarations.append("    real(dp) :: c_cVtb")
        par_definitions.append("    c_cVtb = dble_val_opt('--c_cVtb', 0.0_dp)")
        par_message.append("  --c_cVtb <value>      CKM tb imaginary part (user), default = 0")
    if (par_s12): 
        par_declarations.append("    real(dp) :: c_s12")
        par_definitions.append("    c_s12 = dble_val_opt('--c_s12', 0.23_dp)")
        par_message.append("  --c_s12 <value>       Sine of 12 Euler angle (user), default = 0.23")
    if (par_s13): 
        par_declarations.append("    real(dp) :: c_s13")
        par_definitions.append("    c_s13 = dble_val_opt('--c_s13', 0.0035_dp)")
        par_message.append("  --c_s13 <value>       Sine of 13 Euler angle (user), default = 0.0035")
    if (par_s23): 
        par_declarations.append("    real(dp) :: c_s23")
        par_definitions.append("    c_s23 = dble_val_opt('--c_s23', 0.042_dp)")
        par_message.append("  --c_s23 <value>       Sine of 23 Euler angle (user), default = 0.042")
    if (par_c12): 
        par_declarations.append("    real(dp) :: c_c12")
        par_definitions.append("    c_c12 = dble_val_opt('--c_c12', 0.97_dp)")
        par_message.append("  --c_c12 <value>       Cosine of 12 Euler angle (user), default = 0.97")
    if (par_c13): 
        par_declarations.append("    real(dp) :: c_c13")
        par_definitions.append("    c_c13 = dble_val_opt('--c_c13', 1.0_dp)")
        par_message.append("  --c_c13 <value>       Cosine of 13 Euler angle (user), default = 1")
    if (par_c23): 
        par_declarations.append("    real(dp) :: c_c23")
        par_definitions.append("    c_c23 = dble_val_opt('--c_c23', 0.999_dp)")
        par_message.append("  --c_c23 <value>       Cosine of 23 Euler angle (user), default = 0.999")

    # Additional unknown parameters 
    for unknownpar in foundparameters: 
        # Some "unknown" parameters, we can give a good guess for 
        if (unknownpar == 'c_CF'): 
            par_declarations.append("    real(dp) :: " + unknownpar)
            par_definitions.append("    " + unknownpar + " = dble_val_opt('--" + unknownpar + "', cf)") 
            par_message.append("  --" + unknownpar + " <value>         QCD colour-factor C_F, default = 4/3")
        elif (unknownpar == 'c_CA'): 
            par_declarations.append("    real(dp) :: " + unknownpar)
            par_definitions.append("    " + unknownpar + " = dble_val_opt('--" + unknownpar + "', ca)") 
            par_message.append("  --" + unknownpar + " <value>         QCD colour-factor C_A, default = 3")
        elif (unknownpar == 'c_SUNN'): 
            par_declarations.append("    integer :: " + unknownpar)
            par_definitions.append("    " + unknownpar + " = int_val_opt('--" + unknownpar + "', 3)") 
            par_message.append("  --" + unknownpar + " <value>       Number of colours, default = 3")
        elif (unknownpar == 'c_Nf'): 
            par_declarations.append("    integer :: " + unknownpar)
            par_definitions.append("    " + unknownpar + " = int_val_opt('--" + unknownpar + "', nf_int)") 
            par_message.append("  --" + unknownpar + " <value>         Number of flavours, default = 5")
        elif (unknownpar == 'c_TR'): 
            par_declarations.append("    real(dp) :: " + unknownpar)
            par_definitions.append("    " + unknownpar + " = dble_val_opt('--" + unknownpar + "', tr)") 
            par_message.append("  --" + unknownpar + " <value>         QCD colour-factor T_R, default = 0.5")
        elif (unknownpar == 'c_Tf'): 
            par_declarations.append("    real(dp) :: " + unknownpar)
            par_definitions.append("    " + unknownpar + " = dble_val_opt('--" + unknownpar + "', tf)") 
            par_message.append("  --" + unknownpar + " <value>         QCD parameter, T_f = T_R * nf, default = 2.5")
        elif (unknownpar == 'c_vev'): 
            par_declarations.append("    real(dp) :: " + unknownpar)
            par_definitions.append("    " + unknownpar + " = higgs_vev_in") 
        else: 
            par_declarations.append("    real(dp) :: " + unknownpar)
            par_definitions.append("    " + unknownpar + " = dble_val_opt('--" + unknownpar + "', 1.0_dp)") 
            spacelength = 12 - len(unknownpar) 
            if (spacelength < 0): 
                spacelength = 0 
            par_message.append("  --" + unknownpar + " <value> " + (" " * spacelength) + "User parameter (proc = user), default = 1.0")

    # Container for luminosity code lines 
    lumilines = [] 

    # Loop over all found channels 
    for channel in channels: 

        # Get the first and second particle 
        p1 = ""
        p2 = ""
        if (len(channel) == 2):
            p1 = channel[0]
            p2 = channel[1]
        elif (len(channel) == 5): 
            if (channel.endswith('bar')): 
                p1 = channel[0]
                p2 = channel[1:]
            else: 
                p1 = channel[:4]
                p2 = channel[4]
        elif (len(channel) == 8): 
            p1 = channel[:4]
            p2 = channel[4:]

        # Check for errors 
        acceptedParticles = ['g', 'u', 'd', 'c', 's', 'b', 'q', 'ubar', 'dbar', 'cbar', 'sbar', 'bbar', 'qbar']
        if (p1 not in acceptedParticles): 
            print("WARNING: Unrecognised particle found: " + p1) 
            print("Please only use the following particles: g, u, d, c, s, b, q, ubar, dbar, cbar, sbar, bbar, qbar.")
        if (p2 not in acceptedParticles): 
            print("WARNING: Unrecognised particle found: " + p2) 
            print("Please only use the following particles: g, u, d, c, s, b, q, ubar, dbar, cbar, sbar, bbar, qbar.")

        quarks = ['u', 'd', 'c', 's', 'b', 'q', 'ubar', 'dbar', 'cbar', 'sbar', 'bbar', 'qbar']
        lumi = ''
        if ((p1 == 'g') and (p2 == 'g')): 
            lumi = 'lumi_gg'
        elif ((p1 == 'g') and (p2 in quarks)): 
            lumi = 'lumi_gq' 
        elif ((p2 == 'g') and (p1 in quarks)): 
            lumi = 'lumi_qg' 
        elif ((p1 in quarks) and (p2 in quarks)): 
            lumi = 'lumi_qqbar' 

        pdf1 = ''
        pdf2 = ''
        if ((p1 not in ['q', 'qbar']) and (p2 not in ['q', 'qbar'])): 

            if (p1.endswith('bar')):
                pdf1 = 'pdf1(:, -iflv_' + p1[0] + ')'
            else: 
                pdf1 = 'pdf1(:, iflv_' + p1 + ')'

            if (p2.endswith('bar')):
                pdf2 = 'pdf2(:, -iflv_' + p2[0] + ')'
            else: 
                pdf2 = 'pdf2(:, iflv_' + p2 + ')'

            # Add luminosity line 
            lumilines.append('    ' + lumi + ' = ' + lumi + ' + PartonLuminosity(grid, ' + pdf1 + ', ' + pdf2 + ')') 

        elif (p1 not in ['q', 'qbar']): 

            if (p1.endswith('bar')):
                pdf1 = 'pdf1(:, -iflv_' + p1[0] + ')'
            else: 
                pdf1 = 'pdf1(:, iflv_' + p1 + ')'

            if (p2 == 'q'):
                # Add luminosity line 
                lumilines.append('    do i = 1, 6') 
                lumilines.append('      ' + lumi + ' = ' + lumi + ' + PartonLuminosity(grid, ' + pdf1 + ', pdf2(:, i))') 
                lumilines.append('    end do') 

            elif (p2 == 'qbar'):  
                # Add luminosity line 
                lumilines.append('    do i = 1, 6') 
                lumilines.append('      ' + lumi + ' = ' + lumi + ' + PartonLuminosity(grid, ' + pdf1 + ', pdf2(:, -i))') 
                lumilines.append('    end do') 

        elif (p2 not in ['q', 'qbar']): 

            if (p2.endswith('bar')):
                pdf2 = 'pdf2(:, -iflv_' + p2[0] + ')'
            else: 
                pdf2 = 'pdf2(:, iflv_' + p2 + ')'

            if (p1 == 'q'):
                # Add luminosity line 
                lumilines.append('    do i = 1, 6') 
                lumilines.append('      ' + lumi + ' = ' + lumi + ' + PartonLuminosity(grid, pdf1(:, i), ' + pdf2 + ')') 
                lumilines.append('    end do') 

            elif (p1 == 'qbar'):  
                # Add luminosity line 
                lumilines.append('    do i = 1, 6') 
                lumilines.append('      ' + lumi + ' = ' + lumi + ' + PartonLuminosity(grid, pdf1(:, -i), ' + pdf2 + ')')  
                lumilines.append('    end do') 

        else: 

            # Add luminosity line 
            lumilines.append('    do i = -6, 6') 
            lumilines.append('      if (i == 0) cycle')
            lumilines.append('      ' + lumi + ' = ' + lumi + ' + PartonLuminosity(grid, pdf1(:, i), pdf2(:, -i))') 
            lumilines.append('    end do') 

    # Output to file 
    with open(args.outfile, 'w') as outputfile: 
        outputfile.write("!========================================================\n")
        outputfile.write("!--------------------------------------------------------\n")
        outputfile.write("! Module containing the squared matrix element from\n")
        outputfile.write("! included user code for a custom process\n")
        outputfile.write("! Automatically generated with DressUserAmpCode.py\n")
        outputfile.write("!--------------------------------------------------------\n")
        outputfile.write("!========================================================\n")
        outputfile.write("\n")
        outputfile.write("module user_interface\n")
        outputfile.write("\n")
        outputfile.write("  use ew_parameters\n")
        outputfile.write("  use hoppet_v1\n")
        outputfile.write("  use common_vars\n")
        outputfile.write("  use sub_defs_io\n")
        outputfile.write("\n")
        outputfile.write("  implicit none\n")
        outputfile.write("\n")
        outputfile.write("  private\n")
        outputfile.write("\n")
        outputfile.write("  integer, parameter :: idef = selected_int_kind(8)\n")
        outputfile.write("\n")
        outputfile.write("  public :: user_included, user_cross_section, user_Msquared, user_luminosities, &\n")
        outputfile.write("            & user_help_message\n")
        outputfile.write("\n")
        outputfile.write("contains\n")
        outputfile.write("\n")
        outputfile.write("!=======================================================================================\n")
        outputfile.write("! Test function to see if the user interface is set up and included \n")
        outputfile.write("\n")
        outputfile.write("  integer function user_included() \n")
        outputfile.write("\n")
        outputfile.write("    ! id_noImplementation   = user interface has not been set up \n")
        outputfile.write("    ! id_missingTotXsec     = total born-level cross-section not included \n")
        outputfile.write("    ! id_fullImplementation = full implementation \n")
        outputfile.write("    user_included = " + user_included + " \n") 
        outputfile.write("\n")
        outputfile.write("  end function user_included \n")
        outputfile.write("\n")
        outputfile.write("!=======================================================================================\n")
        outputfile.write("! Born-level cross-section from the generated user code \n")
        outputfile.write("\n")
        outputfile.write("  function user_cross_section(lumigg, lumiqg, lumigq, lumiqqbar) result(res)\n")
        outputfile.write("\n")
        outputfile.write("    real(dp) :: res\n")
        outputfile.write("    real(dp), intent(in) :: lumigg, lumiqg, lumigq, lumiqqbar \n")
        outputfile.write("    real(dp) :: xsgg, xsqg, xsgq, xsqq \n")
        outputfile.write("\n")
        outputfile.write("    ! New parameter declarations\n")
        for i in par_declarations: 
            outputfile.write(i + "\n")
        outputfile.write("\n")
        outputfile.write("    ! New parameter definitions\n")
        for i in par_definitions: 
            outputfile.write(i + "\n")
        outputfile.write("\n")
        outputfile.write("    ! Initial values\n")
        outputfile.write("    xsgg = 0.0_dp\n")
        outputfile.write("    xsqg = 0.0_dp\n")
        outputfile.write("    xsgq = 0.0_dp\n")
        outputfile.write("    xsqq = 0.0_dp\n")
        outputfile.write("\n")
        outputfile.write("    ! Born cross section\n")
        for i in xseclines: 
            outputfile.write(i + "\n")
        outputfile.write("\n")
        outputfile.write("    res = xsgg * lumigg + xsqg * lumiqg + xsgq * lumigq + xsqq * lumiqqbar \n")
        outputfile.write("    res = res * invGev2_to_nb \n")
        outputfile.write("\n")
        outputfile.write("  end function user_cross_section \n")
        outputfile.write("\n")
        outputfile.write("!=======================================================================================\n")
        outputfile.write("! Squared matrix element from the generated user code\n")
        outputfile.write("\n")
        outputfile.write("  subroutine user_Msquared(s, t, u, wtqq, wtqg, wtgq, wtgg)\n")
        outputfile.write("\n")
        outputfile.write("    real(dp), intent(in) :: s, t, u ! Input\n")
        outputfile.write("    real(dp), intent(out) :: wtqq, wtqg, wtgq, wtgg ! Output\n")
        outputfile.write("\n")
        outputfile.write("    ! New parameter declarations\n")
        for i in par_declarations: 
            outputfile.write(i + "\n")
        outputfile.write("\n")
        outputfile.write("    ! New parameter definitions\n")
        for i in par_definitions: 
            outputfile.write(i + "\n")
        outputfile.write("\n")
        outputfile.write("    ! Initial values\n")
        outputfile.write("    wtqq = 0.0_dp\n")
        outputfile.write("    wtqg = 0.0_dp\n")
        outputfile.write("    wtgq = 0.0_dp\n")
        outputfile.write("    wtgg = 0.0_dp\n")
        outputfile.write("\n")
        outputfile.write("    ! Squared amplitudes\n")
        for i in amplitudelines: 
            outputfile.write(i + "\n")
        outputfile.write("\n")
        outputfile.write("  end subroutine user_Msquared\n")
        outputfile.write("\n")
        outputfile.write("!=======================================================================================\n")
        outputfile.write("! Luminosities for the process from the generated user code\n")
        outputfile.write("\n")
        outputfile.write("  subroutine user_luminosities(grid, pdf1, pdf2, lumi_gg, lumi_qg, lumi_gq, lumi_qqbar)\n")
        outputfile.write("\n")
        outputfile.write("    type(grid_def), intent(in) :: grid\n")
        outputfile.write("    real(dp), intent(in) :: pdf1(0:grid%ny,-6:7), pdf2(0:grid%ny,-6:7)\n")
        outputfile.write("    real(dp), intent(inout) :: lumi_gg(0:), lumi_qg(0:), lumi_gq(0:), lumi_qqbar(0:)\n")
        outputfile.write("\n")
        outputfile.write("    ! Initial values\n") 
        outputfile.write("    lumi_gg = 0.0_dp \n")
        outputfile.write("    lumi_gq = 0.0_dp \n")
        outputfile.write("    lumi_qg = 0.0_dp \n")
        outputfile.write("    lumi_qqbar = 0.0_dp \n")
        outputfile.write("\n")
        outputfile.write("    ! Luminosities\n")
        for i in lumilines: 
            outputfile.write(i + "\n")
        outputfile.write("\n")
        outputfile.write("  end subroutine user_luminosities\n")
        outputfile.write("\n")
        outputfile.write("!=======================================================================================\n")
        outputfile.write("! Print any parameter additions to the help message\n")
        outputfile.write("\n")
        outputfile.write("  subroutine user_help_message\n")
        outputfile.write("\n")
        if (len(par_message) > 0): 
            for i in par_message: 
                outputfile.write("    write(*,'(a)') '" + i + "'\n")
            outputfile.write("    write(*,'(a)') ! Blank space for cleaner output \n")
        else: 
            outputfile.write("    ! Deliberately empty\n")
        outputfile.write("\n")
        outputfile.write("  end subroutine user_help_message\n")
        outputfile.write("\n")
        outputfile.write("!=======================================================================================\n")
        outputfile.write("\n")
        outputfile.write("end module user_interface\n")
        outputfile.write("\n")
        outputfile.write("\n")

    print("")
    print("Written dressed Fortran code to: " + args.outfile)
    print("")

    # Print message about additional parameters 
    if (len(par_message) > 0): 
        print("The following additional parameters have been added: ")
        for i in par_message: 
            print(i) 

if __name__ == "__main__": 
    main() 
